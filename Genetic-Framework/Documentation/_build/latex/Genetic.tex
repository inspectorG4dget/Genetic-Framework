% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Genetic Documentation}
\date{October 28, 2012}
\release{1.0}
\author{Ashwin Panchapakesan}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Required Installations}
\label{Required Installs:required-installations}\label{Required Installs::doc}\label{Required Installs:welcome-to-genetic-s-documentation}

\section{Python 2.7}
\label{Required Installs:python-2-7}
This package requires python 2.7 and will not work with python 2.6.
It can easily be transformed into python 2.6 compliant code. Most of the incompatibilities come from list/dict comprehension expressions


\section{PyGame (and all its dependencies)}
\label{Required Installs:pygame-and-all-its-dependencies}
Used in visualization of the included TSP solver


\chapter{Overview - How to use this Framework}
\label{Overview:overview-how-to-use-this-framework}\label{Overview::doc}
If you are making your own evolutionary algorithm, there are several files that you should edit


\section{individual.py}
\label{Overview:individual-py}
This file defines what an individual is (in a class). Generically, an \code{individual} is simply an ordered collection of chromosomes. The original implementation treats each chromosome differently. Therefore, all the chromosomes of an individual are maintained in a \code{list} as opposed to a \code{set}.

Also implemented in this file are methods to the \code{individual} class that help identify an individual, define its \code{hash}, test its equality to another \code{individual} instance, etc


\section{population.py}
\label{Overview:population-py}
This file contains the functions that define population generation.
The important function defined here is {\hyperref[Overview:genPop]{\code{genPop()}}}, which may be used as an interface to creating unique individuals.
\index{genPop() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Overview:genPop}\pysiglinewithargsret{\bfcode{genPop}}{\emph{N}, \emph{chromGenfuncs}, \emph{chromGenParams}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{N} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- the number of individuals in the population

\item {} 
\textbf{chromGenfuncs} (\emph{list of tuples}) -- a list of functions. The ith function is responsible for generating the ith chromosome for the individual. The length of this list is exactly the number of chromosomes in each individual

\item {} 
\textbf{chromGenfuncs} -- list of params for the functions in chromGenfuncs. The ith function in chromGenfuncs is called with the parameters held in the ith tuple of this list

\end{itemize}

\item[{Return type}] \leavevmode
list of unique individuals. Uniqueness is defined by \code{Individual.\_\_eq\_\_}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{chromGenfuncs}
\label{Overview:chromgenfuncs}
chromGenfuncs is a list of functions. The idea here is that each individual in the population is made up of C chromosomes. These C chromosomes are generated independently of each other for each individual in the initial population. Therefore, there must be exactly C functions listed in chromGenfuncs. The \code{i} th function in chromGenfuncs will be used to generate the \code{i} th chromosome of each individual


\subsection{chromGenParams}
\label{Overview:chromgenparams}
chromGenParams is a list of tuples. There should be exactly as many tuples in this list, as there are functions in chromGenfuncs. To generate the ith chromosome for each individual in the population, the ith function in chromGenfuncs is called with the parameters in the ith tuple of chromGenParams as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{chromGenfuncs}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{(}\PYG{o}{*}\PYG{n}{chromGenParams}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

Though that is the general idea behind how {\hyperref[Overview:genPop]{\code{genPop()}}} works, it actually performs this call in a for loop over a \href{http://docs.python.org/library/functions.html\#zip}{\code{zip()}} of chromGenfuncs and chromGenParams

\begin{notice}{note}{Note:}
In order for {\hyperref[Overview:genPop]{\code{genPop()}}} to work, \code{Individual} must implement \code{\_\_hash\_\_()}. This is because {\hyperref[Overview:genPop]{\code{genPop()}}} uses a \code{set} internally before returning a list of individuals as the generated population. As a result, a meaningful \code{\_\_hash\_\_()} must be implemented in \code{Individual}.
\end{notice}


\section{fitness.py}
\label{Overview:fitness-py}
This file contains all selection functions for evaluating the fitness of any individual of the population. The main function in this file is called {\hyperref[Overview:score]{\code{score()}}}.
\index{score() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Overview:score}\pysiglinewithargsret{\bfcode{score}}{\emph{p}, \emph{scorefuncs}, \emph{scorefuncparams}, \emph{SCORES}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{p} (\emph{instance of individual}) -- the individual being evaluated

\item {} 
\textbf{scorefuncs} (\emph{list of functions}) -- a list of functions - one to evaluate each chromosome in the individual

\item {} 
\textbf{scorefuncparams} -- a list of tuples containing the parameters for each of the functions in scorefuncs. Each function will be called by calling scorefuncs{[}i{]}(p, {\color{red}\bfseries{}*}scorefuncparams{[}i{]})

\item {} 
\textbf{SCORES} (\emph{dict \{Individual : number\}}) -- a dict mapping instances of Individual to their fitness

\end{itemize}

\item[{Return type}] \leavevmode
number (the fitness of the individual)

\end{description}\end{quote}

\end{fulllineitems}


\begin{notice}{note}{Note:}
if the individual being evaluated by this function (\code{p}) was not in \code{SCORES} before the function is executed, it will be inserted into \code{SCORES} by this function. Thus, \code{SCORES} is modified in-place by this function as required.
\end{notice}


\section{selection.py}
\label{Overview:selection-py}
This file contains all selection functions for selecting individuals from a population for any purpose.

There are three important functions already implemented:
\begin{enumerate}
\item {} 
{\hyperref[Overview:tournamentSelect]{\code{tournamentSelect()}}}

\item {} 
{\hyperref[Overview:rouletteWheelSelect]{\code{rouletteWheelSelect()}}}

\item {} 
{\hyperref[Overview:getRouletteWheel]{\code{getRouletteWheel()}}}

\end{enumerate}


\subsection{\texttt{tournamentSelect()}}
\label{Overview:tournamentselect}\index{tournamentSelect() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Overview:tournamentSelect}\pysiglinewithargsret{\bfcode{tournamentSelect}}{\emph{pop}, \emph{T}, \emph{w}, \emph{n}, \emph{scorefunc}, \emph{scoreparams}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pop} (\emph{list of Individuals}) -- the population to select from

\item {} 
\textbf{T} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- the number of contestants in each tournament (must be smaller than len(pop))

\item {} 
\textbf{w} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- the number of winners in each tournament (must be smaller than T)

\item {} 
\textbf{n} (\href{http://docs.python.org/library/functions.html\#int}{\emph{int}}) -- the number of Individuals to be selected from the population by Tournament Selection (n\%w should be 0)

\item {} 
\textbf{scorefunc} (\emph{function}) -- the function used to evaluate the fitness of individuals, to determine the winner(s) of a tournament

\item {} 
\textbf{scoreparams} (\href{http://docs.python.org/library/functions.html\#tuple}{\emph{tuple}}) -- the parameters that scorefunc requires, other than the individual itself. The individual is provided along with the unpacked list of params

\end{itemize}

\item[{Return type}] \leavevmode
list of individuals

\end{description}\end{quote}

\end{fulllineitems}



\subsection{\texttt{rouletteWheelSelect()}}
\label{Overview:roulettewheelselect}\index{rouletteWheelSelect() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Overview:rouletteWheelSelect}\pysiglinewithargsret{\bfcode{rouletteWheelSelect}}{\emph{wheel}, \emph{s=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{wheel} (\emph{a list of 3-tuples. Each tuple consists of the individual, the lower bound (float) of its section of the roulette wheel, and the upper bound (float) of its section of the roulette wheel.}) -- a roulette wheel

\item {} 
\textbf{s} (\href{http://docs.python.org/library/functions.html\#float}{\emph{float}}) -- the random number on which the roulette ball lands on the roulette wheel. This is not provided when calling the function (though it may be if desired). Using this, a binary search is performed to find the Individual that bet on a section of the roulette wheel containing this number

\end{itemize}

\item[{Return type}] \leavevmode
single individual

\end{description}\end{quote}

\end{fulllineitems}



\subsection{\texttt{getRouletteWheel()}}
\label{Overview:getroulettewheel}\index{getRouletteWheel() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Overview:getRouletteWheel}\pysiglinewithargsret{\bfcode{getRouletteWheel}}{\emph{pop}, \emph{SCORES}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{pop} (\emph{list of instances of Individual}) -- the population for which a roulette wheel must be made

\item {} 
\textbf{SCORES} (\emph{dict \{Individual:number\}}) -- a dictionary that maps instances of Individual to their fitnesses

\end{itemize}

\item[{Return type}] \leavevmode
list of 3-tuples (Individual, lowerBound, UpperBound)

\end{description}\end{quote}

\end{fulllineitems}



\section{crossover.py}
\label{Overview:crossover-py}
All functions that have to do with crossing over chromosomes between individuals are defined here. There is no generic driver function here as crossovers are defined per GA.


\section{mutation.py}
\label{Overview:mutation-py}
All functions that have to do with mutating chromosomes between individuals are defined here. There is no generic driver function here as mutations are defined per GA


\chapter{individual.py}
\label{individual.py:individual-py}\label{individual.py::doc}
Define an individual to be used for evolution.


\section{Class Variables}
\label{individual.py:class-variables}

\subsection{\texttt{ID}}
\label{individual.py:id}
A trackable ID generator


\section{Instance variables}
\label{individual.py:instance-variables}

\subsection{\texttt{id}}
\label{individual.py:id1}
A trackable identifier for the individual


\subsection{\texttt{chromosomes}}
\label{individual.py:chromosomes}
An ordered collection of the genetic material of this individual. Maintained as a list


\section{Methods}
\label{individual.py:methods}

\subsection{\texttt{\_\_eq\_\_(self, other)}}
\label{individual.py:eq-self-other}
Return True if all chromosomes of self and other are equal (and in the same order).
Else, return False


\subsection{\texttt{\_\_hash\_\_(self)}}
\label{individual.py:hash-self}
Return the hash of the tuple version of all chromosomes

\code{\_\_len\_\_(self)}
Return the number of chromosomes \code{self} is made of.


\subsection{\texttt{\_\_getitem\_\_(self, i)}}
\label{individual.py:getitem-self-i}
Return the \emph{i} th individual


\subsection{\texttt{\_\_setitem\_\_(self, index, obj)}}
\label{individual.py:setitem-self-index-obj}
Set obj as the \emph{index{}`th chromosome of {}`{}`self{}`}


\subsection{\texttt{\_\_contains\_\_(self, chromosome)}}
\label{individual.py:contains-self-chromosome}
Return True if \code{chromosome} is a member of \code{self.chromosomes}.
Else return False


\subsection{\texttt{\_\_repr\_\_(self)}}
\label{individual.py:repr-self}
Return \code{self.id} as a string


\subsection{\texttt{append(self, chrom)}}
\label{individual.py:append-self-chrom}
Append \code{chrom} to \code{self.chromosomes}

\code{count(self, sub, chrom)}
Return the number of occurrences of \code{sub} in the \code{chrom} th chromosome of \code{self}


\chapter{population.py}
\label{population.py::doc}\label{population.py:population-py}

\section{genPop(N, chromGenfuncs, chromGenParams)}
\label{population.py:genpop-n-chromgenfuncs-chromgenparams}
Return a population (list) of N unique individuals.
Each individual has len(chromgGenFuncs) chromosomes.
For each individual, chromosome\_i is generated by calling chromGenFuncs\_i(chromeGenParams\_i)


\section{genCharsChrom(l, chars)}
\label{population.py:gencharschrom-l-chars}
Return a chromosome (list) of length \code{l}, each of which is made up of the characters from chars.


\section{genTour(numCities)}
\label{population.py:gentour-numcities}
This is the chromosome generation function for the traveling salesman problem. This function returns a list of ints. This list is a permeation of \{0, 1, 2, â€¦, numCities-1\} and represents a tour that the traveling salesman would take


\chapter{fitness.py}
\label{fitness.py::doc}\label{fitness.py:fitness-py}

\section{score(p, scorefuncs, scorefuncparams, SCORES)}
\label{fitness.py:score-p-scorefuncs-scorefuncparams-scores}
Return the sum of the fitness of each chromosome of individual p and store the result in SCORES (mapped under p)
The score of the chromosome\_i is determined by the call scorefunc{[}i{]}(p.chromosomes{[}i{]}, {\color{red}\bfseries{}*}scorefuncparams{[}i{]})


\section{scoreOnes(p)}
\label{fitness.py:scoreones-p}
Return the number of `1's in the chromosome p


\section{scoreTSP(tour, DIST)}
\label{fitness.py:scoretsp-tour-dist}
Return the total distance of \code{tour}, a list of ints, representing a tour (each int is a city ID).
\code{DIST} is a dictionary: \{source\_city\_id : \{destination\_city\_id : distance between source\_city and desitantion\_city\} \}


\chapter{selection.py}
\label{selection.py::doc}\label{selection.py:selection-py}

\section{getRouletteWheel(pop, SCORES)}
\label{selection.py:getroulettewheel-pop-scores}
Return a fitness proportional roulette wheel.
A roulette wheel is a list of 3-tuples structured as follows:
(indiv, low, high) where indiv is the individual that bets on the section of the roulette wheel between low and high


\section{rouletteWheelSelect(wheel, s=None)}
\label{selection.py:roulettewheelselect-wheel-s-none}
Perform roulette wheel selection. A wheel is a fitness proportional roulette wheel as returned by the makeRouletteWheel function.
The parameter s is not required thought not disallowed at the time of calling by the evolutionary algorithm. If it is not supplied, it will be set as a random float between 0 and 1.
This function returns the individual that bet on the section of the roulette wheel that contains s


\section{tournamentSelect(pop, T, w, n, scorefunc, scoreparams)}
\label{selection.py:tournamentselect-pop-t-w-n-scorefunc-scoreparams}
Return a list of n indivuduals.
Each of these individuals has been selected by conducting tournaments of size T.
Each tournament may have exactly w winners
Winners of the tournament are the fittest individuals in the tournament as determined by scorefunc


\chapter{crossover.py}
\label{crossover.py:crossover-py}\label{crossover.py::doc}

\section{crossOnes(p1, p2, chrom)}
\label{crossover.py:crossones-p1-p2-chrom}
Take two individuals (\code{p1} and \code{p2} ) and a chromosome number (\code{chrom}).
Crossover the \code{chrom} th chromosome of \code{p1} and \code{p2}.
Return two new individuals that are the same as \code{p1} and \code{p2} , but with the \code{chrom} th chromosome replaced with one of the children from the crossover


\section{injectionco(p1, p2, chrom)}
\label{crossover.py:injectionco-p1-p2-chrom}
Take two individuals (\code{p1} and \code{p2} ) and a chromosome number (\code{chrom}).
Crossover the \code{chrom} th chromosome of \code{p1} and \code{p2} as follows:
\begin{enumerate}
\item {} 
Select distinct points A \textless{} B between 0 and \code{len(p1.chromosomes{[}chrom{]})}

\item {} 
Make an empty child chromosome of length \code{len(p1.chromosomes{[}chrom{]})}

\item {} 
Copy over the genes of \code{p1} from A to (but not including) B into the corresponding genes of the child

\item {} 
Fill in the rest of the genes of the child with the genes from \code{p2}, in the order in which they appear in \code{p2}, making sure not to include alleles that already exist in the child

\end{enumerate}

Return a new individual that are the same as \code{p1} , but with the \code{chrom} th chromosome replaced with the child from the crossover


\chapter{mutaion.py}
\label{mutation.py:mutaion-py}\label{mutation.py::doc}

\section{mutateSingleAllele(p, chrom, chars)}
\label{mutation.py:mutatesingleallele-p-chrom-chars}
Return a new individual, which is the same as \code{p}, but with the \code{chrom} th chromosome changed as follows:
Select a random gene and change its value to something from the choices in \code{chars}


\section{\texttt{swapmut(p, chrom)}}
\label{mutation.py:swapmut-p-chrom}
Get the \code{chrom} th individual in p. Select two random elements in that chromosome and swap their positions in that chromosome
Return a new individual that is the same as \code{p}, but with the above change made to its \code{chrom} th chromosome


\section{\texttt{revmut(p, chrom)}}
\label{mutation.py:revmut-p-chrom}
Get the \code{chrom} th individual in p. Select two random elements in that chromosome and reverse the order of genes between those two elements in that chromosome
Return a new individual that is the same as \code{p}, but with the above change made to its \code{chrom} th chromosome


\section{\texttt{shufflemut(p, chrom)}}
\label{mutation.py:shufflemut-p-chrom}
Get the \code{chrom} th individual in p. Shuffle that chromosome with \code{random.shuffle}
Return a new individual that is the same as \code{p}, but with the above change made to its \code{chrom} th chromosome


\chapter{GA.py}
\label{GA.py::doc}\label{GA.py:ga-py}

\section{runTSPGA(kwargs)}
\label{GA.py:runtspga-kwargs}
Run a GA that solves the Traveling Salesman Problem with the settings generated in settings.py


\section{runGA(kwargs)}
\label{GA.py:runga-kwargs}
Run a simple fitness-maximizing GA that solves any applicable problem. At the time of writing this document, it was applied to the One-Max problem


\chapter{settings.py}
\label{settings.py:settings-py}\label{settings.py::doc}
Since the evolutionary framework requires several settings for each of the modules being used, a separate file is used to specify the correct settings for a run of an evolution.

This file contains functions, each of which generates a specific set of settings to run evolution on a specific problem


\section{Fields}
\label{settings.py:fields}
All fields have to be set with some value or other. There are no default values in this framework, by design


\subsection{testmode}
\label{settings.py:testmode}
Set this to true to run in-function assert statements that check contracts. False otherwise


\subsection{maxGens}
\label{settings.py:maxgens}
The maximum number of generations for which evolution shall be run after which it will be stopped even if an optimal solution has not yet been discovered


\subsection{targetscore}
\label{settings.py:targetscore}
The known optimal fitness score of the problem. Setting this to \code{None} or \code{''} will simulate negative and positive infinity, respectively


\subsection{popsize}
\label{settings.py:popsize}
The number of individuals in the population during evolution


\subsection{numCrossovers}
\label{settings.py:numcrossovers}
The number of crossover operations per generation


\subsection{SCORES}
\label{settings.py:scores}
A dictionary that remembers the fitness values of all individuals. This is used as an optimization. Usually, this is an empty dictionary
This can be deactivated by changing \code{Individual.\_\_hash\_\_} to something that will be unique to each individual, regardless of genetic makeup


\subsection{genfunc}
\label{settings.py:genfunc}
The function that generates the initial population


\subsection{genparams}
\label{settings.py:genparams}
A tuple containing the parameters to send to \code{genfunc} in the correct order


\subsection{scorefunc}
\label{settings.py:scorefunc}
The function that returns the fitness evaluation of an individual. By default this is set to \code{fitness.score}.
.. note:

\begin{Verbatim}[commandchars=\\\{\}]
It is advisable to leave this as {}`{}`fitness.score{}`{}`, especially for multi-chromosome individuals.
\end{Verbatim}


\subsection{scoreparams}
\label{settings.py:scoreparams}
This is a 3-tuple

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textbf{
Index
} & \textbf{
Type
} & \textbf{
Description
}\\\hline

0
 & 
list of functions
 & 
the \emph{i} th function listed here will be used to compute the fitness of the \emph{i} th chromosome of the individuals
\\\hline

1
 & 
list of tuples
 & 
the \emph{i} th tuple listed here contains the parameters (in the correct order) for the \emph{i} th function in the list in index 0
\\\hline

2
 & 
dictionary
 & 
\code{SCORES}
\\\hline
\end{tabulary}


\begin{notice}{warning}{Warning:}
The parameters listed do NOT include any reference to the individual whose fitness will be computed. The individual will be supplied by the main evolution function itself. This is because the individual is chosen by the selection function and therefore cannot be known at the time of making these settings
\end{notice}


\subsection{selectfunc}
\label{settings.py:selectfunc}
The selection function by which individuals will be selected for crossover


\subsection{selectparams}
\label{settings.py:selectparams}
A tuple of parameters (in the correct order) for the selection function

\begin{notice}{warning}{Warning:}
The parameters listed do NOT include any reference to the population from which individuals will be selected. The population will be supplied by the main evolution function itself. This is because the population keeps changing over time and therefore cannot be known at the time of making these settings
\end{notice}


\subsection{crossfunc}
\label{settings.py:crossfunc}
The function that performs crossover between two individuals


\subsection{crossparams}
\label{settings.py:crossparams}
A tuple of parameters (in the correct order) for the crossover function

\begin{notice}{warning}{Warning:}
The parameters listed do NOT include any reference to the individuals to be crossed over. These individuals will be supplied by the main evolution function itself. This is because the individuals are chosen by the selection function and therefore cannot be known at the time of making these settings
\end{notice}


\subsection{mutfunc}
\label{settings.py:mutfunc}
The function that will mutate a given individual


\subsection{mutparams}
\label{settings.py:mutparams}
A tuple of parameters (in the correct order) for the crossover function

\begin{notice}{warning}{Warning:}
The parameters listed do NOT include any reference to the individual to be mutated. This individual will be supplied by the main evolution function itself. This is because the individual is chosen at random (with probability) and therefore cannot be known at the time of making these settings
\end{notice}


\subsection{crossprob}
\label{settings.py:crossprob}
The probability of crossover occurring. Represented as a float in {[}0, 1{]}


\subsection{mutprob}
\label{settings.py:mutprob}
The probability of mutation occurring. Represented as a float in {[}0, 1{]}


\subsection{rouletteWheelRequireres}
\label{settings.py:roulettewheelrequireres}
A set of functions that require a roulette wheel. This is used later in the automated computation some settings


\subsection{getWheel}
\label{settings.py:getwheel}
A \code{bool} that determines whether the evolutionary algorithm must compute a roulette wheel for selection

\begin{notice}{warning}{Warning:}
This is an automatically set parameter. Do not alter it.
\end{notice}


\subsection{visualize}
\label{settings.py:visualize}
A boolean flag that determines if visualization is enabled


\subsection{screenWidth}
\label{settings.py:screenwidth}
The width of the screen created for visualization


\subsection{screenHeight}
\label{settings.py:screenheight}
The height of the screen created for visualization


\subsection{makeScreenParams}
\label{settings.py:makescreenparams}
A tuple of parameters (in the correct order) required to make the screen on which the visualization will be drawn


\subsection{drawParams}
\label{settings.py:drawparams}
A tuple of parameters (in the correct order) required to draw the visualization on the screen


\subsection{fon}
\label{settings.py:fon}
The font with which any text should be written on screen during visualization


\subsection{fontParams}
\label{settings.py:fontparams}
The parameters for rendering font as a tuple 9in the correct order)


\subsection{labelParams}
\label{settings.py:labelparams}
A tuple of parameters (in the correct order) required to place any text in the correct place on screen during visualization


\subsection{sanity}
\label{settings.py:sanity}
A list of parameter names that should be present in the settings.
The settings are checked for the entries in \code{sanity} before any evolution is run, to ensure that all parameters are provided


\subsection{answer}
\label{settings.py:answer}
A dictionary of the settings to run evolution

\begin{notice}{warning}{Warning:}
It is generally a bad idea to alter statements that are not assignment statements. This is because they are automations that generate some settings, thus taking the responsibility of generating those settings away from the programmer. Altering them may have unintended side-effects
\end{notice}

\begin{notice}{warning}{Warning:}
It is generally a bad idea to alter statements that are inside the \code{if visualize} block. This is a block that automates the inclusion of settings (both into the returned settings and the sanity) for visualization if it is enabled
\end{notice}


\chapter{visualization.py}
\label{visualization.py:visualization-py}\label{visualization.py::doc}
This module handles all the visualization for any evolution.
The current implementation uses \code{pygame}


\section{makeScreen(W, H)}
\label{visualization.py:makescreen-w-h}
Make an empty screen of width \code{W} and height \code{H}


\section{normalize(point, (olow, ohigh), (low, high))}
\label{visualization.py:normalize-point-olow-ohigh-low-high}
This is a helper function. It takes a value for \code{point}, originally measured in the scale {[}olow, ohigh{]}.
The returned value is the corresponding value of \code{point} on the scale {[}low, high{]}


\section{draw(tour, window, W, H, SCORES, COORDS)}
\label{visualization.py:draw-tour-window-w-h-scores-coords}
Draws a tour of a traveling salesman, and writes the score of the tour on the window.

Each city in the tour is represented as a red dot, with white lines connecting them.

\code{COORDS} is a dictionary that contains the coordinates of the various cities.

The fitness score of \code{tour} is also written to \code{window}


\section{killscreen()}
\label{visualization.py:killscreen}
This function cleans up pygame and destroys the window and the screen; to be called at the end of evolution.


\chapter{Contracts}
\label{contracts:contracts}\label{contracts::doc}
Contracts are used to check the pre and post conditions of functions to make sure that the evolutionary algorithm remains constrained within the solution space.

All contracts used by all functions are listed here. It is highly recommended that similar functions that are implemented in the future implement similar contracts. This will be explained further as each contract is explaioned.


\section{GA.py}
\label{contracts:ga-py}
The main GA driver has the following contracts. It is highly recommended that any GA implemented to maximize the fitness score should implement these contracts.


\subsection{The main GA runner}
\label{contracts:the-main-ga-runner}

\subsubsection{Preconditions}
\label{contracts:preconditions}\begin{enumerate}
\item {} 
\code{kwargs} should be supplied

\item {} 
\code{kwargs} is a dict mapping argument names (strings) to argument values

\item {} 
The maximum number of generations allowed is greater than 0

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:postconditions}\begin{enumerate}
\item {} 
\code{kwargs} should not be changed

\item {} \begin{description}
\item[{At least one of the following two conditions must hold}] \leavevmode\begin{enumerate}
\item {} 
the fitness of the fittest individual (being returned) is at least \code{targetscore}

\item {} 
the current generation count is equal to the maximum number of generations allowed

\end{enumerate}

\end{description}

\item {} 
the maximum number of generations allowed is greater than 0

\end{enumerate}


\section{Individual.py}
\label{contracts:individual-py}
The following contracts must be followed for any implementation of the \code{Individual} class


\subsection{\texttt{Individual.\_\_hash\_\_(self, other)}}
\label{contracts:individual-hash-self-other}

\subsubsection{Preconditions}
\label{contracts:id1}
None


\subsubsection{Postconditions}
\label{contracts:id2}\begin{enumerate}
\item {} 
an \code{int} should be returned

\item {} 
\code{self} should not be changed

\end{enumerate}

In addition to these, the current implementation has the following methods implemented:


\subsection{\texttt{Individual.\_\_eq\_\_(self, other)}}
\label{contracts:individual-eq-self-other}

\subsubsection{Preconditions}
\label{contracts:id3}\begin{enumerate}
\item {} 
\code{other} should be an instance of \code{Individual}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id4}\begin{enumerate}
\item {} 
\code{other} should not be changed

\item {} 
\code{self} should not be changed

\end{enumerate}


\subsection{\texttt{Individual.\_\_len\_\_(self)}}
\label{contracts:individual-len-self}

\subsubsection{Preconditions}
\label{contracts:id5}
None


\subsubsection{Postconditions}
\label{contracts:id6}\begin{enumerate}
\item {} 
\code{self} should not be changed

\end{enumerate}


\subsection{\texttt{Individual.\_\_setitem\_\_(self, index, obj)}}
\label{contracts:individual-setitem-self-index-obj}

\subsubsection{Preconditions}
\label{contracts:id7}\begin{enumerate}
\item {} \begin{description}
\item[{Exactly one of the following two conditions must be satisfied:}] \leavevmode\begin{enumerate}
\item {} 
0 \textless{}= \code{index} \textless{}= len(self.chromosomes)

\item {} 
len(self.chromosomes)*-1 \textgreater{}= index \textgreater{}= -1

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id8}\begin{enumerate}
\item {} 
The object at \code{self.chromosomes{[}index{]}} should be \code{obj}

\end{enumerate}


\subsection{\texttt{Individual.\_\_contains\_\_(self, chromosome)}}
\label{contracts:individual-contains-self-chromosome}

\subsubsection{Preconditions}
\label{contracts:id9}
None


\subsubsection{Postconditions}
\label{contracts:id10}\begin{enumerate}
\item {} 
\code{self} should not be changed

\item {} 
\code{chromosome} should not be changed

\end{enumerate}


\subsection{\texttt{Individual.\_\_repr\_\_(self)}}
\label{contracts:individual-repr-self}

\subsubsection{Preconditions}
\label{contracts:id11}
None


\subsubsection{Postconditions}
\label{contracts:id12}\begin{enumerate}
\item {} 
\code{self} should not be changed

\end{enumerate}

\code{Individual.append(self, chrom)}
--=--------------------------------


\subsubsection{Preconditions}
\label{contracts:id13}
None


\subsubsection{Postconditions}
\label{contracts:id14}\begin{enumerate}
\item {} 
The length of \code{self.chromosomes} should be increased by exactly 1

\item {} 
The last chromosome in \code{self.chromosomes} should be \code{chrom}

\end{enumerate}


\subsection{\texttt{Individual.count(self, sub, chrom)}}
\label{contracts:individual-count-self-sub-chrom}

\subsubsection{Preconditions}
\label{contracts:id15}
None


\subsubsection{Postconditions}
\label{contracts:id16}\begin{enumerate}
\item {} 
\code{self} should not be changed

\end{enumerate}


\section{population.py}
\label{contracts:population-py}
The following contracts are applied to the functions in population.py


\subsection{\texttt{genPop(N, chromGenfuncs, chromGenParams)}}
\label{contracts:genpop-n-chromgenfuncs-chromgenparams}

\subsubsection{Preconditions}
\label{contracts:id17}\begin{enumerate}
\item {} 
N \textgreater{}= 0

\item {} 
\code{chromGenfuncs} is a list

\item {} 
Every entry in \code{chromGenfuncs} is a function

\item {} 
\code{chromGenParamss} is a list

\item {} 
The lengths of \code{chromGenfuncs} and \code{chromGenParams} are equal

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id18}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
Function returns a list

\item {} 
The length of the returned list is \code{N}

\item {} 
The returned list contains exactly 1 of each item i.e. no two items in the returned list are equal

\end{enumerate}


\subsection{\texttt{genCharsChrom(l, chars)}}
\label{contracts:gencharschrom-l-chars}

\subsubsection{Preconditions}
\label{contracts:id19}\begin{enumerate}
\item {} 
\code{l} is an integer

\item {} 
\code{chars} is an instance of some class that implements \code{\_\_getitem\_\_}

\item {} 
\code{chars} is an instance of some class that implements \code{\_\_len\_\_}

\item {} 
\code{len(chars)} is greater than 0

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id20}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
Function returns a list

\item {} 
The length of the returned list is \code{l}

\item {} 
Every element in the returned list exists in \code{chars}

\end{enumerate}


\subsection{\texttt{genTour(numCities)}}
\label{contracts:gentour-numcities}

\subsubsection{Preconditions}
\label{contracts:id21}\begin{enumerate}
\item {} 
\code{numCities} is an integer

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id22}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
Function returns a list

\item {} 
The length of the returned list is \code{numCities}

\item {} 
Every element in the returned list exists exactly once in the returned list.

\end{enumerate}


\section{score.py}
\label{contracts:score-py}

\subsection{\texttt{score(p, scorefuncs, scorefuncparams, SCORES)}}
\label{contracts:score-p-scorefuncs-scorefuncparams-scores}

\subsubsection{Preconditions}
\label{contracts:id23}\begin{enumerate}
\item {} 
\code{p} is an instance of \code{Individual}

\item {} 
\code{scorefuncs} is a list of functions

\item {} 
\code{scorefuncparams} is a list of tuples

\item {} 
The lengths of \code{scorefuncs} and \code{scorefuncparams} are equal

\item {} 
\code{SCORES} is a dictionary

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id24}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
\code{p} is in \code{SCORES}

\item {} \begin{description}
\item[{Exactly one of the following two conditions are met:}] \leavevmode\begin{enumerate}
\item {} 
\code{p} was in \code{SCORES} before this function was called and the number of entries in \code{SCORES} has not changed

\item {} 
\code{p} was not in \code{SCORES} before this function was called and the number of entries in \code{SCORES} has increased by exactly 1

\end{enumerate}

\end{description}

\end{enumerate}


\subsection{\texttt{scoreOnes(p)}}
\label{contracts:scoreones-p}

\subsubsection{Preconditions}
\label{contracts:id25}\begin{enumerate}
\item {} 
\code{p} is list

\item {} 
All elements in \code{p} are strings of length exactly 1

\item {} 
All elements in \code{p} are either `0' or `1'

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id26}\begin{enumerate}
\item {} 
\code{p} is unchaged

\item {} 
An integer is returned

\item {} 
The value returned is at least 0

\end{enumerate}


\subsection{scoreTSP(tour, DIST)}
\label{contracts:scoretsp-tour-dist}\begin{quote}
\begin{description}
\item[{post:}] \leavevmode
isinstance(\_\_return\_\_, float)

\item[{post{[}tour, DIST{]}:}] \leavevmode
\_\_old\_\_.tour == tour
\_\_old\_\_.DIST == DIST

\end{description}
\end{quote}


\subsubsection{Preconditions}
\label{contracts:id27}\begin{enumerate}
\item {} 
\code{tour} is a list

\item {} 
\code{DIST} is a dictionary

\item {} 
All elements in \code{tour} are integers

\item {} 
All keys in \code{DIST} are integers

\item {} 
All values in \code{DIST} are dictionaries

\item {} 
Every key in every value of \code{DIST} is an integer

\item {} 
Every value in every value of \code{DIST} is a float

\end{enumerate}


\subsubsection{Loop Invariant}
\label{contracts:loop-invariant}\begin{enumerate}
\item {} 
\code{answer} (the value to be returned is at most 0 and monotonously decreases

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id28}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
The function returns a float

\end{enumerate}


\subsection{getRouletteWheel(pop, SCORES)}
\label{contracts:getroulettewheel-pop-scores}

\subsubsection{Preconditions}
\label{contracts:id29}\begin{enumerate}
\item {} 
\code{pop} is a list of instances of \code{Individual}

\item {} 
\code{SCORES} is a dictionary

\item {} 
Every element in \code{pop} is a key in \code{SCORES}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id30}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
A list of 3-tuples of type (Individual, float, float) is returned

\item {} 
The length of the returned list is equal to the length of \code{pop}

\item {} 
The first element of every tuple in the returned list exists in \code{pop}

\item {} 
The second float is smaller than the third float in every tuple in the returned list

\end{enumerate}


\subsection{rouletteWheelSelect(wheel, s=None)}
\label{contracts:roulettewheelselect-wheel-s-none}

\subsubsection{Preconditions}
\label{contracts:id31}\begin{enumerate}
\item {} \begin{description}
\item[{\code{wheel} is a list of 3-tuples which satisfy all the following conditions}] \leavevmode\begin{enumerate}
\item {} 
The first element is an instance of \code{Individual}

\item {} 
The last two elements are floats

\item {} 
The first float is smaller than the second

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{Exactly one of the following two conditions are met:}] \leavevmode\begin{enumerate}
\item {} 
\code{s} is a float

\item {} 
\code{s} is None

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions:}
\label{contracts:id32}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
An instance of \code{Individual} is returned

\end{enumerate}


\subsection{tournamentSelect(pop, T, w, n, scorefunc, scoreparams)}
\label{contracts:tournamentselect-pop-t-w-n-scorefunc-scoreparams}

\subsubsection{Preconditions}
\label{contracts:id33}\begin{enumerate}
\item {} 
\code{pop} is a list of instances of \code{Individual}

\item {} 
\code{T} is an integer

\item {} 
\code{w} is an integer

\item {} 
\code{n} is an integer

\item {} 
\code{w} is at most \code{n}

\item {} 
\code{n\%w} is exactly 0

\item {} 
\code{n} is at most \code{T}

\item {} 
\code{scoreparams} is a tuple

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id34}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
A list of \code{n} instances of \code{Individual} is returned

\end{enumerate}


\section{crossover.py}
\label{contracts:crossover-py}
The following contracts are implemented for the crossover functions.


\subsection{crossOnes(p1, p2, chrom)}
\label{contracts:crossones-p1-p2-chrom}

\subsubsection{Preconditions}
\label{contracts:id35}\begin{enumerate}
\item {} 
\code{p1} and \code{p2} are instances of \code{Individual}

\item {} 
\code{chrom} is an integer

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id36}\begin{enumerate}
\item {} 
The inputs are unchaged

\item {} 
A tuple of two instances of \code{Individual} is returned

\item {} \begin{description}
\item[{Each individual in the return tuple satisfies the following conditions:}] \leavevmode\begin{enumerate}
\item {} 
The \code{chrom} th chromosome is a list of one-character strings

\item {} 
The value of the ith gene of the \code{chrom} th chromosome is exactly the value of the ith gene of the \code{chrom} th chromosome of either \code{p1} or \code{p2}

\end{enumerate}

\end{description}

\end{enumerate}


\subsection{injectionco(p1, p2, chrom)}
\label{contracts:injectionco-p1-p2-chrom}

\subsubsection{Preconditions}
\label{contracts:id37}\begin{enumerate}
\item {} 
\code{p1} and \code{p2} are instances of \code{Individual}

\item {} 
\code{chrom} is an integer

\item {} 
The length of \emph{p1} is exactly equal to the length of \code{p2}

\item {} 
For every element in \code{p1}, there exists an element in \code{p2} of the same type

\item {} 
For every element in \code{p2}, there exists an element in \code{p1} of the same type

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id38}\begin{enumerate}
\item {} 
The inputs are unchaged

\item {} 
A new object is returned

\item {} 
The length of the returned object is eactly equal to the lengths of \code{p1} or \code{p2}

\item {} 
The function returns a permutation i.e. all elements in the returned object occur exactly once

\end{enumerate}


\section{muatation.py}
\label{contracts:muatation-py}

\subsection{mutateSingleAllele(p, chrom, chars)}
\label{contracts:mutatesingleallele-p-chrom-chars}

\subsubsection{Preconditions}
\label{contracts:id39}\begin{enumerate}
\item {} 
\code{p} is an instance of \code{Individual}

\item {} 
\code{chrom} is an integer

\item {} 
The value of each gene in the \code{chrom} th chromosome of \code{p} exists in \code{chars}

\item {} \begin{description}
\item[{Exactly one of the following two conditions must be satisfied:}] \leavevmode\begin{enumerate}
\item {} 
0 \textless{}= \code{index} \textless{}= len(self.chromosomes)

\item {} 
len(self.chromosomes)*-1 \textgreater{}= index \textgreater{}= -1

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id40}\begin{enumerate}
\item {} 
The inputs are unchanged

\item {} 
A new instance of \code{Individual} is returned

\item {} 
The \code{chrom} th chromosome of the returned individual is not equal to the \code{chrom} th chromosome of \code{p}

\item {} 
All other chromosomes of the returned individual are exactly the same as the corresponding chromosome of \code{p}

\end{enumerate}


\subsection{swapmut(p, chrom)}
\label{contracts:swapmut-p-chrom}

\subsubsection{Preconditions}
\label{contracts:id41}\begin{enumerate}
\item {} 
\code{p} is an instance of \code{Individual}

\item {} 
\code{chrom} is an integer

\item {} \begin{description}
\item[{Exactly one of the following two conditions are satisfied:}] \leavevmode\begin{enumerate}
\item {} 
0 \textless{}= \code{chrom} \textless{}= \code{len(p.chromosomes)}

\item {} 
\code{len(self.chromosomes)*-1} \textgreater{}= \code{index} \textgreater{}= -1

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id42}\begin{enumerate}
\item {} 
The inputs are unchaged

\item {} 
An instance of \code{Individual} is returned

\item {} 
All values in the \code{chrom} th chromosome of \code{p} are present in the \code{chrom} th chromosome of the output individual

\item {} 
The \code{chrom} th chromosomes of the output individual and \code{p} are not equal

\item {} 
There are exactly two genes in the \code{chrom} th chromome of \code{p} and the returned individual, whose values differ

\end{enumerate}


\subsection{revmut(p, chrom)}
\label{contracts:revmut-p-chrom}

\subsubsection{Preconditions}
\label{contracts:id43}\begin{enumerate}
\item {} 
\code{p} is an instance of \code{Individual}

\item {} 
\code{chrom} is an integer

\item {} \begin{description}
\item[{Exactly one of the following two conditions are satisfied:}] \leavevmode\begin{enumerate}
\item {} 
0 \textless{}= \code{chrom} \textless{}= \code{len(p.chromosomes)}

\item {} 
\code{len(self.chromosomes)*-1} \textgreater{}= \code{index} \textgreater{}= -1

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id44}\begin{enumerate}
\item {} 
The inputs are unchaged

\item {} 
An instance of \code{Individual} is returned

\item {} 
All values in the \code{chrom} th chromosome of \code{p} are present in the \code{{}`chrom} th chromosome of the output individual

\item {} 
The \code{chrom} th chromosomes of the output individual and \code{p} are not equal

\end{enumerate}


\subsection{shufflemut(p, chrom)}
\label{contracts:shufflemut-p-chrom}\begin{quote}
\begin{description}
\item[{post{[}p, chrom{]}:}] \leavevmode
\_\_old\_\_.p == p
\_\_old\_\_.chrom == chrom
isinstance(\_\_return\_\_, Individual)
\_\_return\_\_.chromosomes{[}chrom{]} != p.chromosomes{[}chrom{]}
forall(p.chromosomes{[}chrom{]}, lambda e: e in \_\_return\_\_.chromosomes{[}chrom{]})
forall(\_\_return\_\_.chromosomes{[}chrom{]}, lambda e: e in p.chromosomes{[}chrom{]})

\end{description}
\end{quote}


\subsubsection{Preconditions}
\label{contracts:id45}\begin{enumerate}
\item {} 
\code{p} is an instance of \code{Individual}

\item {} 
\code{chrom} is an integer

\item {} \begin{description}
\item[{Exactly one of the following two conditions are satisfied:}] \leavevmode\begin{enumerate}
\item {} 
0 \textless{}= \code{chrom} \textless{}= \code{len(p.chromosomes)}

\item {} 
\code{len(self.chromosomes)*-1} \textgreater{}= \code{index} \textgreater{}= -1

\end{enumerate}

\end{description}

\end{enumerate}


\subsubsection{Postconditions}
\label{contracts:id46}\begin{enumerate}
\item {} 
The inputs are unchaged

\item {} 
An instance of \code{Individual} is returned

\item {} 
All values in the \code{chrom} th chromosome of \code{p} are present in the \code{{}`chrom} th chromosome of the output individual

\item {} 
The \code{chrom} th chromosomes of the output individual and \code{p} are not equal

\item {} 
The length of the \code{chrom} th chromosome of the returned individual is exactly equal to the length of the \code{chrom} th chromosome of \code{p}

\end{enumerate}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
